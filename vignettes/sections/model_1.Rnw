\subsection{model\_1 to perform mean comparisons on farms }
\label{model_1}

At the \textbf{farm level}, the residual had few degrees of freedom, leading to a poor estimation of the residual variance and to a lack of power for comparing populations.
Hence, model\_1 was implemented (section~\ref{section_model1}).

For model\_1, it gave nice results with more than 20 environment \citep{riviere_hierarchical_2015}.

\subsubsection{Theory of the model}

The model is describe in \citet{riviere_hierarchical_2015}.
We restricted ourselves to analysing plot means.
The phenotypic value $Y_{ijk}$ for variable $Y$, germplasm $i$, environment $j$ and block $k$ was modelled as :

\begin{equation}
	Y_{ijk} = \mu_{ij} + \beta_{jk} + \varepsilon_{ijk} ; \quad \varepsilon_{ijk} \sim \mathcal{N} (0,\sigma^2_{j}),
	\label{model1}
\end{equation}

where
$\mu_{ij}$ was the mean of germplasm $i$ in environment $j$ (note that this parameter, which corresponds to an entry, confounds the population effect and the population $\times$ environment effect);
$\beta_{jk}$ was the effect of block $k$ in environment $j$ satisfying the constraint\footnote{Note that it is quite different from \citet{riviere_hierarchical_2015} where the model was done only for two blocks. Here there is no restriction on the number of blocks.} $\sum\limits_{k=1}^K \beta_{jk} = 1$ ;
$\varepsilon_{ijk}$ was the residual error;
$\mathcal{N} (0,\sigma^2_{j})$ denoted normal distribution centred on 0 with variance $\sigma^2_{j}$, which was specific to environment $j$.

We took advantage of the similar structure of the trials on each environment of the network to assume that trial residual variances came from a common distribution :

\begin{displaymath}
	\sigma^2_{j} \sim \frac{1}{Gamma(\nu,\rho)},
\end{displaymath}

where $\nu$ and $\rho$ are unknown parameters.
Because of the low number of residual degrees of freedom for each farm, we used a hierarchical approach in order to assess mean differences on farm.
For that, we placed vague prior distributions on the hyperparameters $\nu$ and $\rho$ :

\begin{displaymath}
	\nu \sim Uniform(\nu_{min},\nu_{max}) ; \quad \rho \sim Gamma(10^{-6},10^{-6}).
\end{displaymath}


In other words, the residual variance of a trial within environment was estimated using all the informations available on the network rather than using the data from that particular trial only.

The parameters $\mu_{ij}$ and $\beta_{j1}$ were assumed to follow vague prior distributions~:

\begin{displaymath}
	\mu_{ij} \sim \mathcal{N}(\mu_{.j},10^{6}); \quad \beta_{j1} \sim \mathcal{N}(0,10^{6}).
\end{displaymath}


The inverse gamma distribution has a support bounded by 0 (consistent with the definition of a variance) and may have various shapes including asymmetric distributions.
From an agronomical point of view, the assumption that trial variances were heterogeneous was consistent with organic farming: there were as many environments as farmers leading to a high heterogeneity.
Environment was here considered in a broad sense: practices (sowing date, sowing density, tilling, etc.), pedo climatic conditions, biotic and abiotic stress, \dots \citep{desclaux_changes_2008}.
Moreover, the inverse gamma distribution had conjugate properties that facilitated MCMC convergence.
This model was therefore a good choice based on both agronomic and statistical criteria.

The residual variance estimated from the controls was assumed to be representative of the residual variance of the other entries.
Blocks were included in the model only if the trial had blocks.

\subsubsection{Steps with \pack}

For model\_1, you can follow these steps (Figure \ref{main_workflow}):

\begin{enumerate}
\item Run the model with \texttt{model\_1}
\item Check model outputs with graphs to know if you can continue the analysis with \texttt{check\_model}
\item Get mean comparisons for each factor with \texttt{mean\_comparisons} and \texttt{get\_ggplot}
\end{enumerate}

Let's get the data.
The values for $\mu_{ij}$, $\beta_{jk}$, $\epsilon_{ijk}$ and $\sigma_j$ are the real value taken to create the dataset.
This dataset is representative of data you can get in a PPB programme.

<<message=TRUE,cache=FALSE>>=
data(PPBdata)
head(PPBdata)
@

\subsubsection{Run the model}

To run model~\ref{model1} on the dataset, used the function \texttt{MC}.
You can run it on one variable.
Here it is thousand kernel weight (tkw).

By default, \texttt{model\_1} returns posteriors for 
$\mu_{ij}$ (\texttt{return.mu = TRUE}), 
$\beta_{jk}$ (\texttt{return.beta = TRUE}), 
$\sigma_j$ (\texttt{return.sigma = TRUE}), 
$\nu$ (\texttt{return.nu = TRUE}) and 
$\rho$ (\texttt{return.rho = TRUE}).
You can also get $\epsilon_{ijk}$ value with \texttt{return.espilon = TRUE}.

By default, DIC is not displayed, you may want this value to compare to other model (\texttt{DIC = TRUE}).
DIC criterion is a generalization of the AIC criterion that can be used for hierarchical models \citep{spiegelhalter_bayesian_2002}.
The smaller the DIC value, the better the model \citep{plummer_penalized_2008}.

<<message=TRUE,cache=FALSE>>=
# out_model_1 = model_1(data = PPBdata, variable = "tkw", return.epsilon = TRUE)

# Compiling model graph
# Resolving undeclared variables
# Allocating nodes
# Graph information:
#   Observed stochastic nodes: 976
# Unobserved stochastic nodes: 927
# Total graph size: 8609
# 
# Initializing model
# 
# |++++++++++++++++++++++++++++++++++++++++++++++++++| 100%
# |**************************************************| 100%
# |**************************************************| 100%
# |**************************************************| 100%

load(paste(path, "out_model_1.RData", sep = "")) # To save time
@

You can get informations of the environments in the dataset :

<<message=TRUE,cache=FALSE>>=
out_model_1$vec_env_with_no_data
 
out_model_1$vec_env_with_no_controls
 
out_model_1$vec_env_with_controls
 
out_model_1$vec_env_RF
 
out_model_1$vec_env_SF
@

Below is an example with low \texttt{nb\_iterations}:
<<message=TRUE,cache=FALSE>>=
# out_model_1_bis = model_1(data = PPBdata, variable = "tkw", nb_iteration = 5000)

# Compiling model graph
# Resolving undeclared variables
# Allocating nodes
# Graph information:
#   Observed stochastic nodes: 976
# Unobserved stochastic nodes: 927
# Total graph size: 8609
# 
# Initializing model
# 
# |++++++++++++++++++++++++++++++++++++++++++++++++++| 100%
# |**************************************************| 100%
# |**************************************************| 100%
# Warning message:
#   In model_1(data = PPBdata, variable = "tkw", nb_iteration = 5000) :
#   nb_iterations is below 20 000, which seems small to get convergence in the MCMC.

load(paste(path, "out_model_1_bis.RData", sep = ""))
@

\subsubsection{Check and visualize model outputs}

\paragraph{Check the model}

Once the model is run, it is necessary to check if the outputs can be taken with confidence.
This step is needed before going ahead in the analysis (in fact, the MCMC object used in the next functions must come from \texttt{check\_model}).

<<message=TRUE,cache=FALSE>>=
# out_check_model_1 = check_model(out_model_1)

# The Gelman-Rubin test is running for each parameter ...
# The two MCMC for each parameter converge thanks to the Gelman-Rubin test.

load(paste(path, "out_check_model_1.RData", sep = ""))
@

\texttt{out\_check\_model\_1} is a list containing:

\begin{itemize}
\item "MCMC" : a data fame resulting from the concatenation of the two MCMC for each parameter. This object can be used for further analysis. There are as many columns than parameters and as many rows than iterations//thin (the thin value is 10 by default in the models).
<<message=TRUE,cache=FALSE>>=
dim(out1$MCMC)
@

\item "MCMC_conv_not_ok": a data fame resulting from the concatenation of the two MCMC for each parameter for environment where  some parameters did not converge for mu and beta

\item "data_env_with_no_controls" : dataframe with environnement with no controls

\item "data_env_whose_param_did_not_converge" : a list with data frame with environments where some parameters did not converge for mu and beta

\item "data_ggplot" : a list containing information for ggplot:
\begin{itemize}
\item sigma_j
\item mu_ij
\item beta_jk
\item sigma_j_2
\item epsilon_ijk
\end{itemize}

\end{itemize}

When considering \texttt{out\_model\_1\_bis}:
<<message=TRUE,cache=FALSE>>=
out_check_model_1_bis = check_model(out_model_1_bis)

# The Gelman-Rubin test is running for each parameter ...
# The two MCMC of the following parameters do not converge thanks to the Gelman-Rubin test : nu, rho, sigma[env2-2:2010]. Therefore, they are not present in MCMC output.
# MCMC are updated, the following environment were deleted : env2-2:2010
# data_env_whose_param_did_not_converge contains the raw data for these environments.

load(paste(path, "out_check_model_1_bis.RData", sep = ""))
@


\paragraph{Visualize outputs}
Once the computation is done, you can visualize the results with \texttt{get\_ggplot}
<<message=TRUE,cache=FALSE>>=
p_out_check_model_1 = get_ggplot(out_check_model_1)
@

\texttt{p\_out\_check\_model\_1} is a list with:

\begin{itemize}

\item \texttt{sigma\_j\_gamma} : mean of each sigma_j displayed on the Inverse Gamma distribution. The first graph represent all the sigma_j, the other graph represent \textttt{nb\_parameters\_per\_plot} \texttt{sigma\_j} per graph.
<<message=TRUE,cache=FALSE>>=
p_out_check_model_1$sigma_j_gamma[[1]]
p_out_check_model_1$sigma_j_gamma[[2]]
@

\item \texttt{mu\_ij} : distribution of each mu_ij in a list with as many elements as environment. For each element of the list, there are as many graph as needed with \code{nb_parameters_per_plot} mu_ij per graph.
<<message=TRUE,cache=FALSE>>=
names(p_out_check_model_1$mu_ij)

names(p_out_check_model_1$mu_ij$`env1-1:2010`)

p_out_check_model_1$mu_ij$`env1-1:2010`$`1`
@

\item \texttt{beta\_jk} : distribution of each beta_jk in a list with as many elements as environment. For each element of the list, there are as many graph as needed with \code{nb_parameters_per_plot} beta_jk per graph.
<<message=TRUE,cache=FALSE>>=
names(p_out_check_model_1$beta_jk)

names(p_out_check_model_1$beta_jk$`env1-1:2010`)

p_out_check_model_1$beta_jk$`env1-1:2010`$`1`
@


\item \texttt{sigma\_j} : distribution of each sigma_j. There are as many graph as needed with \code{nb_parameters_per_plot} sigma_j per graph.
<<message=TRUE,cache=FALSE>>=
names(p_out_check_model_1$sigma_j)

p_out_check_model_1$sigma_j[[1]]
@


\item \texttt{epsilon\_ijk} : standardised residuals distribution.
If the model went well it should be between -2 and 2.
<<message=TRUE,cache=FALSE>>=
p_out_check_model_1$epsilon_ijk
@

\item \texttt{mcmc\_not\_converge\_traceplot\_density} : a list with the plots of trace and density to check the convergence of the two MCMC only for chains that are not converging thanks to the Gelman-Rubin test. 
If all the chains converge, it is NULL
<<message=TRUE,cache=FALSE>>=
p_out_check_model_1$mcmc_not_converge_traceplot_density
@
Here all the parameters converge.


When considering \texttt{p\_out\_check\_model\_1\_bis}, there is no convergence because the MCMC are too small.

<<message=TRUE,cache=FALSE>>=
p_out_check_model_1_bis = get_ggplot(out_check_model_1_bis)

p_out_check_model_1_bis$mcmc_not_converge_traceplot_density$`sigma\\[env2-2:2010`
@

\end{itemize}

Just for fun, you can compare the posterior medians and the arithmetic means for the $\mu_{ij}$.

<<message=TRUE,cache=FALSE>>=
MCMC = out_check_model_1$MCMC
effects = apply(MCMC, 2, median)
mu_ij_estimated = effects[grep("mu",names(effects))]
names(mu_ij_estimated) = sapply(names(mu_ij_estimated), 
                                function(x){  sub("\\]", "", sub("mu\\[", "", x)) } 
                                )

d = filter(PPBdata, location != "env4")
d = filter(d, location != "env5")
d = droplevels(d)
environment = paste(as.character(d$location), as.character(d$year), sep = ":")
d$entry = as.factor(paste(as.character(d$germplasm), environment, sep = ","))
mu_ij = tapply(d$mu_ij, d$entry, mean, na.rm = TRUE)

check = cbind.data.frame(mu_ij, mu_ij_estimated[names(mu_ij)])
@

Let's have a look on the relation between the posterior medians and the arithmetic means.
It goes pretty well!

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
p = ggplot(check, aes(x = mu_ij, y = mu_ij_estimated))
p + stat_smooth(method = "lm") + geom_point()
@
\end{figure}



\subsubsection{Get mean comparisons}

Get mean comparisons with \texttt{mean\_comparisons}.
The theory behind mean comparisons are explained in section \ref{mean_comp}.

<<message=TRUE,cache=FALSE>>=
# out_mean_comparisons_model_1_mu = mean_comparisons(out_check_model_1, parameter = "mu")

# Get at least X groups for env2-1:2011. It may take some time ...
# Get at least X groups for env2-1:2011 is done.
# Get at least X groups for env2-13:2011. It may take some time ...
# Get at least X groups for env2-13:2011 is done.
# Get at least X groups for env2-3:2012. It may take some time ...
# Get at least X groups for env2-3:2012 is done.
# Get at least X groups for env2-9:2010. It may take some time ...
# Get at least X groups for env2-9:2010 is done.

load(paste(path, "out_mean_comparisons_model_1_mu.RData", sep = ""))
@

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
A CONTINUER FAIRE Rd mean comp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

\texttt{out_mean_comparisons_model_1_mu} is a list of three elements:
\begin{itemize}
\item
\item
\item
\end{itemize}

<<message=TRUE,cache=FALSE>>=
head(out_mean_comparisons_model_1_mu$data_mean_comparisons$`env1-1:2010`$mean.comparisons)

head(out_mean_comparisons_model_1_mu$data_env_with_no_controls)

head(out_mean_comparisons_model_1_mu$data_env_whose_param_did_not_converge)
@

<<message=TRUE,cache=FALSE>>=
p = get_ggplot(out_mean_comparisons_model_1_mu, ggplot.type = "barplot")
p = get_ggplot(out_mean_comparisons_model_1_mu, data_version = data_version, ggplot.type = "barplot")
p = get_ggplot(out_mean_comparisons_model_1_mu, ggplot.type = "score")
p = get_ggplot(out_mean_comparisons_model_1_mu, ggplot.type = "interaction")
@



\paragraph{Plots}

\subparagraph{All entries in a given environment}

To see the output, use \texttt{get.ggplot}.
On each plot, the \texttt{alpha} (type one error) value and the alpha correction are displayed.
\texttt{alpha = Imp} means that no differences were possible to find.
For \texttt{ggplot.type = "interaction"} and \texttt{ggplot.type = "score"}, it is display under the form: \texttt{alpha | alpha correction}.

<<message=TRUE,cache=FALSE>>=
p_barplot = get.ggplot(comp.mu, ggplot.type = "barplot")
length(p_barplot)
names(p_barplot)
@

\begin{figure}[H]

<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
# For environment env-1-1:2010
grid.arrange(p_barplot$"env1-1:2010"[[1]], p_barplot$"env1-1:2010"[[2]] , ncol = 2, nrow = 1)
grid.arrange(p_barplot$"env1-1:2010"[[2]], p_barplot$"env1-1:2010"[[4]], ncol = 2, nrow = 1)
@
\end{figure}

With \texttt{ggplot.type = "interaction"}, you can display the year effect as well as detect groups.
One group is represented by one dashed line.
Germplasms which share the same group are not different.
Germplasms which do not share the same groupe are different (section \ref{mean_comp}).

<<message=TRUE,cache=FALSE>>=
p_interaction = get.ggplot(comp.mu, ggplot.type = "interaction")
@

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
# For location env-1-1.
p_interaction$"env1-1"[[1]]
@
\end{figure}

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
p_interaction$"env1-1"[[2]]
@
\end{figure}

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
p_interaction$"env1-1"[[3]]
@
\end{figure}
             
\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
p_interaction$"env1-1"[[4]]
@
\end{figure}

For the score, more entries are displayed.
An high score means that the entry was in a group with an high mean.
A low socre means that the entry was in a group with an low mean.
This plot is useful to look at year effects.

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
p_score = get.ggplot(comp.mu, ggplot.type = "score", nb_parameters_per_plot = 15)
# For location env-1-1
grid.arrange(p_score$"env1-1"[[1]], p_score$"env1-1"[[2]] , ncol = 2, nrow = 1)
@
\end{figure}

The same method is used for each $\beta_{jk}$.

\vspace{.5cm}

For environments with no controls or where at least one MCMC did not converge, it may be useful to get the plot as well.

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
get.ggplot(out.model1$data_env_with_no_controls, ggplot.type = "barplot")
@
\end{figure}

You can also do a plot with interaction. 
Here it is not useful as there is only one year.

\begin{figure}[H]
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
g = get.ggplot(out1_bis$model1.data_env_whose_param_did_not_converge, ggplot.type = "barplot")

names(g)

g$`env1-1:2012`$`1`
@
\end{figure}


\subparagraph{Pairs of entries in a given environment}
It is possible to get comparison of paris of entries in a given location.
This is useful if you want to compare two versions within a group.
For exemple:

<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
data(data_version)
head(data_version)
@

Here, in location \texttt{env1-1}, \texttt{tem-1} and \texttt{tem-2} are two version belonging to the same groupe.

Lets' make the plots:
<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
g = get.ggplot(data = comp.mu, data_version = data_version, ggplot.type = "barplot")
g$`env1-1:2010`$`1`
@

The stars corresponds to the pvalue:

\begin{center}
\begin{tabular}{cc}
\hline
pvalue & stars \\
\hline
$< 0.001$ & *** \\
$[0.001 , 0.05]$ & ** \\
$[0.05 , 0.01]$ & * \\
$> 0.01$ & . \\
\hline
\end{tabular}
\end{center}

The pvalue is computed as describe in section \ref{mean_comp} if the parameters have been estimated with the model.

It is also possible to make this kind of plots for data that did not converge or without environments.
In this case, it is a \texttt{t.test} which is perform.

<<message=TRUE,cache=FALSE,out.width=".6\\textwidth">>=
g = get.ggplot(out1_bis$model1.data_env_whose_param_did_not_converge, data_version = data_version, ggplot.type = "barplot")

g = get.ggplot(out.model1$data_env_with_no_controls, data_version = data_version, ggplot.type = "barplot")
@


