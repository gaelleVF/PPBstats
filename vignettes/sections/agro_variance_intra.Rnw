\subsection{Variance intra : to estimate variance within germplasm}
\label{variance_intra}

\subsubsection{Theory of the model}

The phenotypic value $Y_{ijkl}$ for a given variable $Y$, germplasm $i$, environment $j$, plot $k$ and individual $l$ is modeled as :

\begin{displaymath}
Y_{ijkl} = \mu_{ijk} + \varepsilon_{ijkl} ; \quad \varepsilon_{ijkl} \sim \mathcal{N} (0,\sigma^2_{ij}),
\label{modele_varIntra}
\end{displaymath}


Where $Y_{ijkl}$ is the phenotypic value for germplasm $i$, environment $j$, plot $k$ and individual $l$;
$\mu_{ijk}$ is the mean of population $i$ in environnement $j$ and plot $k$ (nested in environment $j$);
$\varepsilon_{ijkl}$ is what is not explained by the model in germplasm $i$, environment $j$, plot $k$ and individual $l$. 

$\varepsilon_{ijkl}$ is taken from a normal distribution, centered on 0 with variance $\sigma^2_{ij}$

With priors :
\begin{displaymath}
\sigma^2_{ij} \sim 1/Gamma(10^{-6},10^{-6})
\end{displaymath}
and
\begin{displaymath}
\mu_{ijk} \sim N(\mu_{.j.},10^{6})
\end{displaymath}

$\sigma^2_{ij}$ correspond to the intra-germplasm variance.

No specific experimental design is needed as long as there are several individuals measured for a given germplasm.

\subsubsection{Steps with \pack}

For variance intra analysis, you can follow these steps (Figure \ref{main_workflow}) :

\begin{enumerate}
\item Run the model with \texttt{model\_variance\_intra} 
\item Check model outputs with graphs to know if you can continue the analysis with \texttt{check\_model}
\item Get mean comparisons for each factor with \texttt{mean\_comparisons} and vizualise it with \texttt{plot}
\end{enumerate}

Let's get the data.

<<message=TRUE,cache=FALSE>>=
data(data_model_variance_intra)
data_model_variance_intra = format_data_PPBstats(data_model_variance_intra, type = "data_agro")
@


\subsubsection{Run the model}
To run the model , used the function \texttt{model\_variance\_intra}.
You can run it on one variable.

<<message=TRUE,cache=FALSE>>=
#out_vi = model_variance_intra(data_model_variance_intra, variable = "spike_weight", nb_iterations = 100)
@


\subsubsection{Check and visualize model outputs}

\paragraph{Check the model}

Once the model is run, it is necessary to check if the outputs can be taken with confidence.
This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from \texttt{check\_model}).

<<message=TRUE,cache=FALSE>>=
out_check_vi = check_model(out_vi)
@

\paragraph{Visualize outputs}

Once the computation is done, you can visualize the results with \texttt{plot}

<<message=TRUE,cache=FALSE>>=
p_out_check_vi = plot(out_check_vi)
@

\subsubsection{Get and visualize mean comparisons}

\paragraph{Get mean comparisons}

Get mean comparisons with \texttt{mean\_comparisons}.

<<message=TRUE,cache=FALSE>>=
out_mean_comparisons_vi = mean_comparisons(out_check_vi, parameter = "mu", p.adj = "soft.bonf")
@

\paragraph{Visualize outputs}

Once the computation is done, you can visualize the results with \texttt{plot}

<<message=TRUE,cache=FALSE>>=
p_out_mc_vi = plot(out_mean_comparisons_vi)
@


\subsubsection{Apply the workflow to several variables}
\label{workflow_variance_intra}

If you wish to apply the variance\_intra workflow to several variables, you can use \texttt{lapply} with the following code :

<<message=TRUE,cache=FALSE>>=
workflow_model_variance_intra = function(x){
  out_vi = model_variance_intra(data_variance_intra, variable = x)
  
  out_check_vi = check_model(out_vi)
  p_out_check_vi = plot(out_check_vi)
  
  out_mean_comparisons_vi = mean_comparisons(out_check_vi, p.adj = "bonferroni")
  p_out_mean_comparisons_vi = plot(out_mean_comparisons_vi)
  
  out = list(
    "out_vi" = out_vi,
    "out_check_vi" = out_check_vi,
    "p_out_check_vi" = p_out_check_vi,
    "out_mean_comparisons_vi" = out_mean_comparisons_vi,
    "p_out_mean_comparisons_vi" = p_out_mean_comparisons_vi
  )
  
  return(out)
}

## Not run because of memory and time issues !
# vec_variables = c("y1", "y2", "y3")
#
# out = lapply(vec_variables, workflow_model_variance_intra)
# names(out) = vec_variables

@


